import router from '@ohos.router';
import promptAction from '@ohos.promptAction';
import common from '@ohos.app.ability.common';
import curves from '@ohos.curves';
import { getCountryByCode } from '../../utils/countryData';
import { MemoryLevel, getMemoryLevel, getAllMemoryLevels } from './MemoryLevels';
import { GameProgressManager, GameType } from '../../utils/GameProgressManager';
import { SoundEffectUtil } from '../../utils/SoundEffectUtil';
import { VibratorUtil } from '../../utils/VibratorUtil';
import { getContentMaxWidth } from '../../utils/LayoutHelper';

interface RouterParams {
  levelId: number;
}

interface Card {
  id: number;
  code: string;
  isFlipped: boolean;
  isMatched: boolean;
}

@Entry
@Component
  struct MemoryPlayPage {
  @State level: MemoryLevel | undefined = undefined;
  @State cards: Card[] = [];
  @State firstCard: Card | null = null;
  @State secondCard: Card | null = null;
  @State moves: number = 0;
  @State matchedPairs: number = 0;
  @State isProcessing: boolean = false;
  @State timeRemaining: number = 0;
  @State showResult: boolean = false;
  @State isWin: boolean = false;
  @State flippingCardId: number = -1;  // æ­£åœ¨ç¿»è½¬çš„å¡ç‰‡ID
  @State flipAngles: Map<number, number> = new Map();  // æ¯å¼ å¡ç‰‡çš„ç¿»è½¬è§’åº¦
  private timerId: number | undefined = undefined;
  private context = getContext(this) as common.UIAbilityContext;
  private timeoutIds: number[] = []; // å­˜å‚¨æ‰€æœ‰setTimeoutçš„IDï¼Œç”¨äºæ¸…ç†

  async aboutToAppear() {
    // åˆå§‹åŒ–éŸ³æ•ˆæ’­æ”¾å™¨
    await SoundEffectUtil.init(this.context);
    await VibratorUtil.init(this.context);

    const params = router.getParams() as RouterParams;
    if (params) {
      const levelId = params.levelId || 1;
      this.loadLevel(levelId);
    }
  }

  private loadLevel(levelId: number): void {
    // æ¸…ç†ä¹‹å‰çš„å®šæ—¶å™¨
    this.clearAllTimeouts();
    this.level = getMemoryLevel(levelId);
    if (this.level) {
      this.timeRemaining = this.level.timeLimit;
      this.cards = [];
      this.firstCard = null;
      this.secondCard = null;
      this.moves = 0;
      this.matchedPairs = 0;
      this.isProcessing = false;
      this.showResult = false;
      this.isWin = false;
      this.flippingCardId = -1;
      this.flipAngles = new Map();
      this.stopTimer();
      this.initCards();
      this.startTimer();
    }
  }

  aboutToDisappear() {
    this.stopTimer();
    // æ¸…ç†æ‰€æœ‰setTimeout
    this.clearAllTimeouts();
    // é‡Šæ”¾éŸ³æ•ˆèµ„æº
    SoundEffectUtil.release();
  }

  private clearAllTimeouts(): void {
    for (const id of this.timeoutIds) {
      clearTimeout(id);
    }
    this.timeoutIds = [];
  }

  private initCards(): void {
    if (!this.level) return;

    const tempCards: Card[] = [];
    let id = 0;

    // åˆ›å»ºé…å¯¹å¡ç‰‡
    for (const code of this.level.countries) {
      tempCards.push({ id: id++, code, isFlipped: false, isMatched: false });
      tempCards.push({ id: id++, code, isFlipped: false, isMatched: false });
    }

    // æ´—ç‰Œ
    this.shuffleArray(tempCards);
    this.cards = tempCards;
  }

  private shuffleArray<T>(array: T[]): void {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      const temp = array[i];
      array[i] = array[j];
      array[j] = temp;
    }
  }

  private startTimer(): void {
    if (!this.level || this.level.timeLimit === 0) return;
    // é˜²æ­¢é‡å¤å¯åŠ¨å®šæ—¶å™¨
    if (this.timerId !== undefined) return;

    this.timerId = setInterval(() => {
      if (this.timeRemaining > 0) {
        this.timeRemaining--;
        if (this.timeRemaining === 0) {
          this.stopTimer();
          this.gameOver(false);
        }
      }
    }, 1000);
  }

  private stopTimer(): void {
    if (this.timerId !== undefined) {
      clearInterval(this.timerId);
      this.timerId = undefined;
    }
  }

  private flipCard(card: Card): void {
    if (this.isProcessing || card.isFlipped || card.isMatched || this.flippingCardId !== -1) return;

    // ç‚¹å‡»æŒ¯åŠ¨åé¦ˆ
    VibratorUtil.vibrateTap();

    const index = this.cards.findIndex(c => c.id === card.id);
    if (index === -1) return;

    // å¼€å§‹ç¿»è½¬åŠ¨ç”»
    this.flippingCardId = card.id;
    this.flipAngles.set(card.id, 180);

    // åŠ¨ç”»ä¸­é€”æ›´æ–°å¡ç‰‡çŠ¶æ€ï¼ˆç¿»è½¬åˆ°ä¸€åŠæ—¶æ˜¾ç¤ºæ­£é¢ï¼‰
    const id1 = setTimeout(() => {
      this.cards[index] = this.createCard(card.id, card.code, true, card.isMatched);
      // ç§»é™¤å·²æ‰§è¡Œçš„å®šæ—¶å™¨ID
      const index1 = this.timeoutIds.indexOf(id1);
      if (index1 > -1) {
        this.timeoutIds.splice(index1, 1);
      }
    }, 200);
    this.timeoutIds.push(id1);

    // åŠ¨ç”»ç»“æŸåå¤„ç†é€»è¾‘
    const id2 = setTimeout(() => {
      this.flippingCardId = -1;

      if (!this.firstCard) {
        this.firstCard = this.cards[index];
      } else if (!this.secondCard) {
        this.secondCard = this.cards[index];
        this.moves++;
        this.isProcessing = true;

        // æ£€æŸ¥æ˜¯å¦åŒ¹é…
        const id3 = setTimeout(async () => {
          await this.checkMatch();
          // ç§»é™¤å·²æ‰§è¡Œçš„å®šæ—¶å™¨ID
          const index3 = this.timeoutIds.indexOf(id3);
          if (index3 > -1) {
            this.timeoutIds.splice(index3, 1);
          }
        }, 500);
        this.timeoutIds.push(id3);
      }
      // ç§»é™¤å·²æ‰§è¡Œçš„å®šæ—¶å™¨ID
      const index2 = this.timeoutIds.indexOf(id2);
      if (index2 > -1) {
        this.timeoutIds.splice(index2, 1);
      }
    }, 400);
    this.timeoutIds.push(id2);
  }

  private createCard(id: number, code: string, isFlipped: boolean, isMatched: boolean): Card {
    return { id: id, code: code, isFlipped: isFlipped, isMatched: isMatched };
  }

  private async checkMatch(): Promise<void> {
    if (!this.firstCard || !this.secondCard) return;

    const firstIndex = this.cards.findIndex(c => c.id === this.firstCard!.id);
    const secondIndex = this.cards.findIndex(c => c.id === this.secondCard!.id);
    const firstId = this.firstCard.id;
    const secondId = this.secondCard.id;

    if (this.firstCard.code === this.secondCard.code) {
      // åŒ¹é…æˆåŠŸ - æ’­æ”¾æ­£ç¡®éŸ³æ•ˆå’ŒæŒ¯åŠ¨
      await SoundEffectUtil.playCorrect();
      VibratorUtil.vibrateCorrect();

      const first = this.cards[firstIndex];
      const second = this.cards[secondIndex];
      this.cards[firstIndex] = this.createCard(first.id, first.code, first.isFlipped, true);
      this.cards[secondIndex] = this.createCard(second.id, second.code, second.isFlipped, true);
      this.matchedPairs++;

      this.firstCard = null;
      this.secondCard = null;
      this.isProcessing = false;

      // æ£€æŸ¥æ˜¯å¦å®Œæˆ
      if (this.matchedPairs === this.level?.pairs) {
        this.stopTimer();
        const id = setTimeout(async () => {
          await SoundEffectUtil.playCongrats();
          VibratorUtil.vibrateWin();
          this.gameOver(true);
          // ç§»é™¤å·²æ‰§è¡Œçš„å®šæ—¶å™¨ID
          const index = this.timeoutIds.indexOf(id);
          if (index > -1) {
            this.timeoutIds.splice(index, 1);
          }
        }, 500);
        this.timeoutIds.push(id);
      }
    } else {
      // ä¸åŒ¹é…ï¼Œç¿»å›å» - æ’­æ”¾é”™è¯¯éŸ³æ•ˆå’ŒæŒ¯åŠ¨
      await SoundEffectUtil.playIncorrect();
      VibratorUtil.vibrateIncorrect();

      this.flipAngles.set(firstId, 0);
      this.flipAngles.set(secondId, 0);

      // åŠ¨ç”»ä¸­é€”æ›´æ–°å¡ç‰‡çŠ¶æ€
      const id1 = setTimeout(() => {
        const first = this.cards[firstIndex];
        const second = this.cards[secondIndex];
        this.cards[firstIndex] = this.createCard(first.id, first.code, false, first.isMatched);
        this.cards[secondIndex] = this.createCard(second.id, second.code, false, second.isMatched);
        // ç§»é™¤å·²æ‰§è¡Œçš„å®šæ—¶å™¨ID
        const index1 = this.timeoutIds.indexOf(id1);
        if (index1 > -1) {
          this.timeoutIds.splice(index1, 1);
        }
      }, 200);
      this.timeoutIds.push(id1);

      // åŠ¨ç”»ç»“æŸåé‡ç½®çŠ¶æ€
      const id2 = setTimeout(() => {
        this.flipAngles.delete(firstId);
        this.flipAngles.delete(secondId);
        this.firstCard = null;
        this.secondCard = null;
        this.isProcessing = false;
        // ç§»é™¤å·²æ‰§è¡Œçš„å®šæ—¶å™¨ID
        const index2 = this.timeoutIds.indexOf(id2);
        if (index2 > -1) {
          this.timeoutIds.splice(index2, 1);
        }
      }, 400);
      this.timeoutIds.push(id2);
    }
  }

  private async gameOver(win: boolean): Promise<void> {
    this.isWin = win;
    this.showResult = true;

    // å¦‚æœå¤±è´¥ï¼Œæ’­æ”¾ç»“æŸéŸ³æ•ˆ
    if (!win) {
      await SoundEffectUtil.playOver();
    }

    // å¦‚æœè·èƒœï¼Œè§£é”ä¸‹ä¸€å…³
    if (win && this.level) {
      await GameProgressManager.init(this.context);
      await GameProgressManager.unlockNextLevel(GameType.MEMORY, this.level.id);
    }
  }

  private restartGame(): void {
    this.cards = [];
    this.firstCard = null;
    this.secondCard = null;
    this.moves = 0;
    this.matchedPairs = 0;
    this.isProcessing = false;
    this.showResult = false;
    this.isWin = false;
    this.flippingCardId = -1;
    this.flipAngles = new Map();

    if (this.level) {
      this.timeRemaining = this.level.timeLimit;
      this.stopTimer();
      this.initCards();
      this.startTimer();
    }
  }

  private formatTime(seconds: number): string {
    const min = Math.floor(seconds / 60);
    const sec = seconds % 60;
    return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
  }

  private getGridColumns(): string {
    // æ ¹æ®å…³å¡é…ç½®çš„åˆ—æ•°ç”Ÿæˆæ¨¡æ¿
    const columns = this.level?.columns || 2;
    const arr: string[] = [];
    for (let i = 0; i < columns; i++) {
      arr.push('1fr');
    }
    return arr.join(' ');
  }

  private getGridRows(): string {
    // æ ¹æ®å¡ç‰‡æ•°é‡å’Œåˆ—æ•°è®¡ç®—è¡Œæ•°
    if (!this.level) return '1fr 1fr 1fr 1fr';
    const totalCards = this.level.pairs * 2;
    const columns = this.level.columns;
    const rows = Math.ceil(totalCards / columns);
    const arr: string[] = [];
    for (let i = 0; i < rows; i++) {
      arr.push('1fr');
    }
    return arr.join(' ');
  }

  private getQuestionMarkSize(): number {
    // æ ¹æ®åˆ—æ•°è°ƒæ•´é—®å·å­—ä½“å¤§å°
    const columns = this.level?.columns || 2;
    if (columns <= 2) return 36;
    if (columns <= 3) return 28;
    if (columns <= 4) return 24;
    return 20;
  }

  private getCardBorderRadius(): number {
    // æ ¹æ®åˆ—æ•°è°ƒæ•´åœ†è§’å¤§å°
    const columns = this.level?.columns || 2;
    if (columns <= 2) return 12;
    if (columns <= 4) return 8;
    return 6;
  }

  build() {
    Stack() {
      Navigation() {
        Row() {
          Column() {
            // é¡¶éƒ¨çŠ¶æ€æ 
            Row() {
            // æ­¥æ•°
            Column() {
              Text($r('app.string.moves'))
                .fontSize(12)
                .fontColor($r('app.color.text_secondary'))
              Text(`${this.moves}`)
                .fontSize(20)
                .fontWeight(FontWeight.Bold)
                .fontColor($r('app.color.text_primary'))
            }
            .layoutWeight(1)

            // æ—¶é—´ï¼ˆæ”¾åœ¨ä¸­é—´ï¼‰
            if (this.level && this.level.timeLimit > 0) {
              Column() {
                Text($r('app.string.time'))
                  .fontSize(11)
                  .fontColor($r('app.color.text_secondary'))
                Text(this.formatTime(this.timeRemaining))
                  .fontSize(16)
                  .fontWeight(FontWeight.Bold)
                  .fontColor(this.timeRemaining <= 10 ? $r('app.color.color_red') : $r('app.color.text_primary'))
              }
              .layoutWeight(1)
            }

            // é…å¯¹è¿›åº¦
            Column() {
              Text($r('app.string.pairs'))
                .fontSize(12)
                .fontColor($r('app.color.text_secondary'))
              Text(`${this.matchedPairs}/${this.level?.pairs || 0}`)
                .fontSize(20)
                .fontWeight(FontWeight.Bold)
                .fontColor($r('app.color.text_primary'))
            }
            .layoutWeight(1)
          }
          .width('100%')
            .padding({ left: 20, right: 20, top: 16, bottom: 16 })

          // å¡ç‰‡ç½‘æ ¼ - é™åˆ¶åœ¨å±å¹•å†…ä¸æ»šåŠ¨
          Grid() {
            ForEach(this.cards, (card: Card) => {
              GridItem() {
                this.CardItem(card)
              }
            })
          }
          .columnsTemplate(this.getGridColumns())
            .rowsTemplate(this.getGridRows())
            .columnsGap(4)
            .rowsGap(4)
            .width('100%')
            .layoutWeight(1)
            .padding({ left: 16, right: 16, top: 12, bottom: 12 })
          }
          .width('100%')
          .height('100%')
          .backgroundColor($r('app.color.bg_page'))
          .constraintSize({ maxWidth: getContentMaxWidth() })
        }
        .width('100%')
        .height('100%')
        .justifyContent(FlexAlign.Center)
      }
      .title('')
      .titleMode(NavigationTitleMode.Mini)
      .mode(NavigationMode.Stack)
      .backgroundColor($r('app.color.bg_page'))

      // ç»“æœå¼¹çª—
      if (this.showResult) {
        this.ResultDialog()
      }
    }
    .width('100%')
      .height('100%')
  }

  @Builder
  CardItem(card: Card) {
    Column() {
      if (card.isFlipped || card.isMatched) {
        // æ˜¾ç¤ºå›½æ—— - åº”ç”¨åå‘æ—‹è½¬ä»¥æŠµæ¶ˆå¡ç‰‡ç¿»è½¬
        Image($rawfile(`flags/${card.code}.svg`))
          .width('75%')
          .height('75%')
          .objectFit(ImageFit.Contain)
          .rotate({
            x: 0,
            y: 1,
            z: 0,
            angle: -this.getCardRotateAngle(card),
            centerX: '50%',
            centerY: '50%'
          })
          .animation({
            duration: 400,
            curve: curves.springMotion(0.4, 0.8)
          })
      } else {
        // æ˜¾ç¤ºå¡ç‰‡èƒŒé¢ - ç™½è‰²èƒŒæ™¯ï¼Œæ——å¸œemoji
        Column() {
          Text('ğŸ³ï¸')
            .fontSize(this.getQuestionMarkSize())
            .fontWeight(FontWeight.Bold)
        }
        .width('100%')
          .height('100%')
          .justifyContent(FlexAlign.Center)
          .alignItems(HorizontalAlign.Center)
      }
    }
    .width('100%')
      .height('100%')
      .justifyContent(FlexAlign.Center)
      .backgroundColor(card.isMatched ? $r('app.color.bg_green_light') :
        (card.isFlipped ? $r('app.color.bg_secondary') : Color.White))
      .borderRadius(this.getCardBorderRadius())
      .border({
        width: card.isMatched ? 2 : 1,
        color: card.isMatched ? $r('app.color.color_green') : $r('app.color.gray_border')
      })
      .shadow(card.isFlipped || card.isMatched ? {
        radius: 8,
        color: 'rgba(0, 0, 0, 0.1)',
        offsetX: 0,
        offsetY: 2
      } : {
        radius: 0,
        color: 'rgba(0, 0, 0, 0)',
        offsetX: 0,
        offsetY: 0
      })
      .rotate({
        x: 0,
        y: 1,
        z: 0,
        angle: this.getCardRotateAngle(card),
        centerX: '50%',
        centerY: '50%'
      })
      .scale({
        x: card.isFlipped || card.isMatched ? 1 : 0.95,
        y: card.isFlipped || card.isMatched ? 1 : 0.95
      })
      .animation({
        duration: 400,
        curve: curves.springMotion(0.4, 0.8)
      })
      .onClick(() => {
        this.flipCard(card);
      })
  }

  private getCardRotateAngle(card: Card): number {
    // å¦‚æœå¡ç‰‡æ­£åœ¨ç¿»è½¬åŠ¨ç”»ä¸­
    if (this.flippingCardId === card.id) {
      return 180;
    }
    // å¦‚æœå¡ç‰‡éœ€è¦ç¿»å›å»
    if (this.flipAngles.has(card.id)) {
      return this.flipAngles.get(card.id) || 0;
    }
    // æ­£å¸¸çŠ¶æ€
    return card.isFlipped || card.isMatched ? 180 : 0;
  }

  @Builder
  ResultDialog() {
    Stack({ alignContent: Alignment.Center }) {
      // é®ç½©å±‚
      Column()
        .width('100%')
        .height('100%')
        .backgroundColor('rgba(0, 0, 0, 0.6)')

      // å¯¹è¯æ¡†
      Column() {
        Text(this.isWin ? 'ğŸ‰' : 'â°')
          .fontSize(56)
          .margin({ top: 24 })

        Text(this.isWin ? $r('app.string.congratulations') : $r('app.string.time_up'))
          .fontSize(24)
          .fontWeight(FontWeight.Bold)
          .fontColor($r('app.color.text_primary'))
          .margin({ top: 16 })

        Text(this.context.resourceManager.getStringSync($r('app.string.level_number').id, (this.level?.id || 1).toString()))
          .fontSize(14)
          .fontColor($r('app.color.text_secondary'))
          .margin({ top: 8 })

        // ç»Ÿè®¡ä¿¡æ¯
        Column() {
          Row() {
            Text($r('app.string.total_moves'))
              .fontSize(15)
              .fontColor($r('app.color.text_secondary'))
            Blank()
            Text(`${this.moves}`)
              .fontSize(15)
              .fontWeight(FontWeight.Bold)
              .fontColor($r('app.color.text_primary'))
          }
          .width('100%')
            .padding({ top: 12, bottom: 12 })

          Divider().color($r('app.color.gray_very_light'))

          Row() {
            Text($r('app.string.pairs_completed'))
              .fontSize(15)
              .fontColor($r('app.color.text_secondary'))
            Blank()
            Text(`${this.matchedPairs} / ${this.level?.pairs}`)
              .fontSize(15)
              .fontWeight(FontWeight.Bold)
              .fontColor($r('app.color.text_primary'))
          }
          .width('100%')
            .padding({ top: 12, bottom: 12 })
        }
        .width('100%')
          .padding({ left: 20, right: 20 })
          .margin({ top: 20 })
          .backgroundColor($r('app.color.bg_secondary'))
          .borderRadius(12)

        // æŒ‰é’®
        Row({ space: 12 }) {
          Button(this.context.resourceManager.getStringSync($r('app.string.back').id))
            .layoutWeight(1)
            .height(44)
            .fontSize(16)
            .fontWeight(FontWeight.Medium)
            .fontColor($r('app.color.button_primary'))
            .backgroundColor(Color.Transparent)
            .border({ width: 1, color: $r('app.color.button_primary') })
            .onClick(() => {
              router.back();
            })

          Button(this.isWin 
            ? (this.level && this.level.id < getAllMemoryLevels().length 
              ? this.context.resourceManager.getStringSync($r('app.string.next_level').id)
              : this.context.resourceManager.getStringSync($r('app.string.perfect_finish').id))
            : this.context.resourceManager.getStringSync($r('app.string.restart').id))
            .layoutWeight(1)
            .height(44)
            .fontSize(16)
            .fontWeight(FontWeight.Bold)
            .backgroundColor($r('app.color.button_primary'))
            .onClick(async () => {
              await SoundEffectUtil.playButton();
              VibratorUtil.vibrateTap();
              if (this.isWin) {
                // èƒœåˆ©ï¼šä¸‹ä¸€å…³æˆ–é€€å‡º
                if (this.level && this.level.id < getAllMemoryLevels().length) {
                  // ä¸‹ä¸€å…³ - åœ¨å½“å‰é¡µé¢é‡æ–°åŠ è½½æ•°æ®
                  await GameProgressManager.init(this.context);
                  await GameProgressManager.unlockNextLevel(GameType.MEMORY, this.level.id);
                  this.loadLevel(this.level.id + 1);
                } else {
                  // å®Œç¾æ”¶å®˜ï¼Œé€€å‡º
                  router.back();
                }
              } else {
                // å¤±è´¥ï¼šé‡æ–°å¼€å§‹
                this.restartGame();
              }
            })
        }
        .width('100%')
          .padding({ left: 20, right: 20 })
          .margin({ top: 24, bottom: 24 })
      }
      .width('85%')
        .constraintSize({ maxWidth: 320 })
        .backgroundColor($r('app.color.bg_card'))
        .borderRadius(20)
    }
    .width('100%')
      .height('100%')
  }
}
